# 存储技术
1. 存储器系统（memory system）是由不同容量、成本和访问时间的存储设备组成的层次结构。在这个层次结构中：CPU 寄存器保存最常用的数据。靠近CPU的小的、快速的高速缓存存储器作为相对慢速的主存储器中数据和指令的缓冲区域。主存又作为容量较大、速度较慢的磁盘上数据的缓冲区域。而磁盘又可以作为通过网络中其他机器上数据的缓冲区域。
2. 存储器层次结构对应用程序的性能有者巨大的影响。假如数据存储在寄存器中，那么0 个时钟周期内就能访问到它们；如果存储在高速缓存中，则需要4 ∼ 75 个周期；如果存储在主存中，需要上百个周期；如果存储在磁盘上，则需要约几千万个周期。之所以会有这样的差异，是由于不同存储器中使用的存储技术不同。
3. 基本的存储技术包括SRAM 存储器、DRAM 存储器、ROM 存储器、旋转硬盘以及固态硬盘。
   1. 随机访问存储器（Random-Access Memory, RAM）分为两类：静态的动态的。静态RAM（SRAM）比动态RAM（DRAM）更快，但也更贵。SRAM 常用来作为高速缓存存储器。DRAM 常用来作为主存以及图形系统的帧缓冲区。
   2. SRAM 是存储技术中随机访问存储器（Random-Access Memory, RAM）的一种。SRAM 将每个位存储在一个双稳态（bistable）存储器单元中，其中每个单元用一个六晶体管电路来实现。所谓双稳态，指的是该存储器单元可以无限期地保持在两个不同的电压配置（configuration）之一。也就是说，只要有电，SRAM 存储器单元就会永远保持它的值，即使有干扰扰乱电压，当干扰消除时电路就会恢复到稳定值。
   3. DRAM 将每个位存储为对一个电容的充电，存储器单元由一个电容和一个访问晶体管组成。与SRAM 不同，DRAM 存储器单元对干扰非常敏感，且受到干扰后永远不会恢复。<br>有很多原因会导致DRAM 单元漏电，使得它在10 ∼ 100 毫秒内失去电荷。但由于计算机运行的时钟周期是以纳秒来衡量的，因此相对来说DRAM 单元电荷保持的时间还是比较长的。由于这个原因，内存系统会周期性地通过读出后重写来刷新内存中的每一位。有些系统还使用纠错码来发现并纠正一个字中任何单个地错误位。
   4. 磁盘存储：前面介绍的随机访问存储器必须在有电的时候才能存取数据，而磁盘则能够永久存储大量的数据。不过，从磁盘上读信息的时间为毫秒级，比从DRAM 读数据慢了10 万倍，比从SRAM 读数据慢100 万倍。

# 局部性
1. 所谓局部性，指的是在每次引用数据时倾向于引用最近引用过的数据项邻近的数据项，或最近引用过的数据项本身。一个编写良好的程序通常要求具有好的局部性。局部性分为时间局部性和空间局部性。良好的时间局部性指的是被引用过一次的数据项会在不远的将来再次被多次引用；良好的空间局部性指的是，如果某个数据在某个位置被引用了一次，那么在不远的将来将引用它附近的内存位置。
2. 步长为1 的引用模式时空间局部性较好的引用模式。一般来说，步长越大，空间局部性就越差。例如在最后一个例子中，虽然看上去也是一个接一个地引用数组中的元素，但由于引用顺序没有按照数组的行优先存储顺序来引用，所以这实际上是个步长为N 的引用模式。

# 存储器的层次结构
1. 存储器层次结构请见chapter1
2. 缓存：
   1. 高速缓存是作为更大、更慢的存储设备的一个缓冲区域，它相对而言更小、更快速。存储器层次结构的中心思想是，对于每个k，位于k 层的更快更小的存储设备作为位于k + 1 层更大更慢的存储设备的缓存。
   2. 在存储器层次结构中，第k + 1 层的存储器被划分成连续的数据对象组块（chunk），称为块（block）。每个块都有一个唯一的地址或名字。通常块的大小是固定的，但也可能是可变的（例如存储在Web 服务器上的远程HTML 文件）。在第k 层中，存储器被划分成较少的块的集合，其中每个块的大小与k + 1 层中的块的大小相同。这样，数据就以块大小为传送单元在第k 层和k + 1 层之间来回复制。
3. 缓存命中：
   1. 当程序需要第k + 1 层的某个数据对象d 时，它首先在当前存储在第k 层的一个块中查找d。如果d 刚好缓存在第k 层中，那就称为缓存命中，这时程序直接从第k层读取d。由于第k 层相对于k + 1 层来说是更块的存储设备，因此读取速度比从第k + 1 层读取更快。
4. 缓存不命中
   1. 如果程序在第k 层中找不到缓存数据对象d，那么就是缓存不命中。当缓存不命中时，就需要从第k 层中取出包含d 的那个块，此时如果k 层的缓存已经满了，那么就可能会覆盖现存的一个块。
   2. 覆盖一个现存块的过程称为替换或驱逐这个块。决定该替换哪个块是由缓存的替换策略控制的。例如，随机替换策略会随机替换一个块；而LRU 替换策略会选择替换最后被访问的时间距现在最远的块。
      1. 如果一个缓存是空的，那就称它为冷缓存（cold cache)。。冷缓存对任何数据对象的访问都会不命中，这类不命中称为强制性不命中（compulsory miss）或冷不命中（cold miss）。冷不命中通常是短暂的事件，不会在存储器的稳定状态中出现。
      2. 如果发生了不命中，那么第k 层的缓存就必须执行某个放置策略（placement policy），来确定把从第k + 1 层中取出来的块放在哪里。
      3. 冲突不命中（conflict miss）。
         1. 在这种情况下，部分对象会被映射到同一个缓存块，导致缓存一直不命中
         2. 实际上，靠近CPU 的缓存是通过硬件实现的，实现随机放置块的代价很高，因此硬件缓存通常使用更严格的放置策略。这个策略将第k + 1 层的某个块限制放置在第k 层块的一个小的子集中（有时只是一个块）。例如可以限制第k + 1 层的块i 必须放置在第k 层的块(i mod 4) 中。这样第k +1 层的块0、4、8 和12 都会被映射到第k 层的块0 中
5. 高速缓存存储器
   1. 高速缓存的操作分为三步：1）组选择；2）行匹配；3）字抽取。其中组选择较为简单，高速缓存从w 的地址中抽取出s 个组索引位。这些位被解释成一个对于于一个组号的无符号整数。
   2. 假设已经确定了某个组i 接下来要确定是否有字w 的一个副本存储在某个组i 包含的一个高速缓存行中。由于在直接映射高速缓存中，每个组只有一行。因此当且仅当设置了有效位，而且高速缓存行中的标记w 与地址中的标记相匹配时，这一行中包含w 的一个副本。
   3. 接下来我们要确定所需要的字在块中是从哪里开始的，这通过块偏移位就可看出。例如块偏移位是1002，则表明w 的副本是从块的字节4 开始的（假设字长为4 字节）。
   4. 如果发生了缓存不命中，那么就需要从存储器层次结构的下一层中取出所请求的块并存储在组索引位指示的组中的一个高速缓存行中。如果组中都是有效高速缓存行，那么就用新取出的行替换当前的行。
6. 相联高速缓存：
   1. 在组相联高速缓存中，每个组都有多于一个的高速缓存行。通常称1 < E < C/B的高速缓存为E 路组相联高速缓存。
   2. 当组相联高速缓存中发生不命中时，需要选择行替换策略。常见的行替换策略有最不常使用（Least-Frequently-Used, LFU）策略和最近最少使用（Least Recently-Used,LRU）策略。
   3. 全相联高速缓存由一个包含所有高速缓存行的组（E = C/B）组成。在全相联高速缓存中，由于只有一个组，不需要进行组选择。此外行匹配和字选择与组相联高速缓存都是一样的
7. 有关写的问题
   1. 如果某个高速缓存更新了某一个字w 的副本，那么还需要更新w 在第一层中的副本
   2. 直写：即立即将w 写回到低一层中。这样做的缺点是每次都会引起总线流量。
   3. 是写回，即尽可能地推迟更新，直到替换算法要驱逐这个更新过的块时再写到低一层中。这样做的缺点是增加了复杂性，因为需要知道某个高速缓存块是否被修改过。
   4. 写不命中的问题
      1. 写分配，即加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块
      2. 非写分配，即直接把这个字写到低一层中。直写高速缓存通常是非写分配的，写回高速缓存通常是写分配的