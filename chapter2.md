# 信息存储
## 1. 一些基础概念
   1. 位：0或1
   2. 溢出：计算机只以有限的位表示数字，如果结果太大超过了位的表示，就会产生溢出
   3. 由于计算机精度有限，浮点运算是不可结合的
   4. 字节：最小的可寻址内存单位，计算机无法直接访问位，最小只能访问到字节。一般8bit=1byte
   ![](./pic/chapter2/1.PNG)
   5. 程序将内存视为一个非常大的数组，称为虚拟内存。
   6. 地址：内存的每一个字节均由一个唯一的数字标识，称为（虚拟）内存的地址。这些所有的地址的集合就称为虚拟地址空间
## 2. 十六进制
1. 一般简写为hex
2. 0~9和A~F代表16个可能的值
3. C语言中以0x或者0X开头标识十六进制。表示16进制时，A和F可以不用大写，可以大小写混写
4. 转换窍门：
   1. 十六进制转换成二进制：将十六进制每个数字转换成二进制，并且拼接成一个整数字串
   ![](./pic/chapter2/3.png)
   2. 二进制转16进制：从右至左，每四个数字为一组，最左侧的一组可能不足4个数字，用0在左侧补足即可
   ![](./pic/chapter2/4.png)
   3. 十进制转二进制：当$x=2^n$，此时x可以简单写成二进制，为1后面跟着n个0
   4. 十进制转16进制：
      1. 如果$x=2^n$，那么有n=i+4j，则转成16进制时首个数字为$2^i$，首个数字后紧跟j个0。比如$2048=2^11$，则$n=11=3+4*2$，从而16进制表示为：0x800
      2. 用数字除以16，得到商q和余数r。r为16进制最低位数字，然后q反复执行这个过程，可以得到16进制的数字：
      ![](./pic/chapter2/5.png)
   5. 任意进制转10进制：比如有一个由$a_1$为最高位的n位的16进制数字，那么就为$a_1 * 16^{n-1}*……*a_i * 16^0$
## 3. 字
1. 每台计算机都有一个字长，知名指针数据的大小。
2. 虚拟地址以这样的一个字进行编码。字长决定了虚拟地址空间最大值。![](./pic/chapter2/2.PNG)
3. 32位程序与64位程序的区别在于编译时采用多少位大小的字长，而非运行机器的类型
4. 64位的字长为64bit，也就是说一般使用8字节地址；32位系统一般使用4字节地址

## 4. 寻址与字节顺序
1. 多字节对象一般被储存为连续的字节序列，对象的地址为所用字节中最小的地址。比如int32 x，4个字节为0x100、0x101、0x102、0x103，但是x的地址为0x100
2. 大端法：最高有效字节存储在最前面，也就是低地址处。你可以把它看成是一种正序存储![](./pic/chapter2/6.PNG)
3. 小端法：最低有效字节存储在在最前面，你可以理解为一种逆序存储
![](./pic/chapter2/7.PNG)
4. 在上面的例子中，x为一个int，十六进制为0x01234567。一个字最多只能装2个16进制数字，因为一个字如果是8bit，那么10进制取值范围为0~255，那么FF已经是可以达到的最大值
5. 具体使用什么端，要看系统设计。两种都很流行。现在甚至还有双端操作系统，即人工手动设定到底采用小端还是大端

## 5. 表示字符串
1. C语言中，字符串被编码为NULL 字符（值为0）结尾的字符数组，每个字符都由某个标准编码来进行表示，最常见的是ASCII
![](./pic/chapter2/8.PNG)
2. 十进制阿拉伯数字0~9的ASCII码都是0x3i，i为对应的数字。比如十进制数字9的ascii是0x39。字符串最后必以00终止（即null）。因此字符串“12345”的16进制码为 31 32 33 34 35 00.</br>
3. 使用ascii码表示字符串在任何系统上结果相同，因此文本数据比二进制数据具有更强的平台独立性

## 6. 位运算
1. 与非或异或：
![](./pic/chapter2/9.PNG)<br>
非：$\neg$<br>
与：$\land$<br>
或：$\lor$<br>
异或：$\bigoplus$，P和Q为真但是不能同时为真
2. 位向量运算：两个等长的，由01构成的向量进行布尔运算，例子如下：
![](./pic/chapter2/10.png)
3. “与”对“或”满足分配率，“或”也对“与”满足分配率
4. 加法逆元：值x，存在一个值-x使得，x+(-x)=0，那么-x称为加法逆元
5. 布尔环：长度为w的位向量进行非、异或、与运算时，可以形成布尔环。布尔环中，用全0的位向量表示0。那么加法运算为异或，此时任何值a的加法逆元为自己。并且布尔环中，加法满足结合律(a^b)^a=0
6. 位向量表示有限集合：<br>
   1. 有全集$U={0,1,...,w-1}$，A为全集U的子集，w为位向量长度根据具体集合。比如给定所有集合中最大元素为8，那么w就设定为9
   2. 位向量：$[a_{w-1},...,a_1,a_0]$。如果$i \in A$，那么$a_i=1$。比如$S={0,1}$,那么位向量表示为$[011]$
   3. |对于集合运算的并，&对应交，~对应补。比如$A={0,3,5,6}$,有位向量$a=[01101001]$;$B={0,2,4,6}$,有位向量 $b=[01010101]$。A和B的交集为 A&B，位向量为[01000001]

## 7. C语言中的高级运算
1. 位运算
   1. 位运算有非、与、或、异或四种
   2. 对于一个表达式的布尔运算结果最好方法就是把数值转换成二进制，执行二进制运算后再转回16进制
   ![](./pic/chapter2/11.png)
   1. 掩码运算：
      1. 提取最低有效字节的掩码运算：<br>
      x=0x89ABCDEF,x&0xFF=0x000000EF。其中，0xFF就是我们所说的最低有效字节掩码
      1. ~0意思为生成一个全为1的掩码
2. 逻辑运算：
   1. 逻辑运算符：
      1. OR：||
      2. AND：&&
      3. NOT：！
   2. 逻辑运算与位运算的区分：
      1. 逻辑运算认为非0参数都是true，参数0是false：![](./pic/chapter2/12.png)。但是位运算的求解结果明显与这个是不同的
      2. 逻辑运算符&&和||，如果第一个参数求值就能得出结果，那么逻辑运算符就不会管第二个参数求值。比如：a&&b，如果a是false，那么不会判断b的正确性。所以if(a && 5/a)这条语句在a=0时依然成立，不会有5/0的计算
3. 移位运算：
   1. 移位运算时从左至右可结合的，`x<<j<<k`等价于`(x<<j)<<k`
   2. 左移：`<<` </br>
   一个变量x的位表示为$[x_{w-1},...,w_1,w_0]$，进行左移k位`x<<k`，就有[x_{w-k-1},x_{w-k-2},...,x_0,...,0]。左移会将最高的k位全部舍弃，并在最后的k位补0。<br>
   k的区间值为$0~w-1$
   3. 右移：`>>`
      1. 逻辑右移：右移k位后，在最左端k位补0
      2. 算术右移：右移k位后，在最左端k位补上k个$x_{w-1}$
      3. C语言标准没有规定哪种右移方式，但是一般编译器对于**有符号数**采用算数右移，**无符号数**采用逻辑右移
      4. java对于右移有明确定义。`x>>>k`表示逻辑右移，`x>>k`表示算数右移
   4. 例子：斜体就是我们补得位<br>![](./pic/chapter2/13.png)
   5. 如果$k \ge w$会发生什么:
      1. 移位指令会执行`k mod w`大小的位移量
      2. C语言程序不一定有这种执行，所以尽量不要这样做
      3. 例子:<br>
      ![](./pic/chapter2/14.png)![](./pic/chapter2/15.png)
   6. 移位操作的优先级：移位操作优先级往往比普通运算低。比如`1<<2+3<<4`，计算机会理解为`(1<<(2+3))<<4`，而不是`(1<<2)+(3<<4)`

# 整数表示
1. 在有符号数据类型的整型数据中，负数也就是下界的绝对值比上界大1<br>
![](./pic/chapter2/16.png)
1. 在C语言最低标准中，我们要求除了像int32这种规定大小的数据类型外，其余数据类型均满足对称要求。并且int可以用2个字节，long可以用4个字节实现![](./pic/chapter2/17.png)
2. 正负号表示
   1. 真值：带有正负号的二进制数
   2. 在计算机中约定: 在有符号数的前面增加1位符号位，用0表示正号，用1表示负号
   3. 机器数：种在计算机中用0和1表示正负号的数
   4. 正负号表示的三种形式
      1. 原码：
         1. 正数符号位用0表示，负数符号位用1表示
         2. X=+1010110，那么$[x]_{原}=01010110$
         3. 0的原码不唯一，可以是$[+0]_{原}=00000000$，也可是$[-0]_{原}=10000000$
         4. 原码的问题：原码处理加减法会很困难
            1. 比如000000001+10000000=10000010，就会得出1+(-1)=-2的奇怪结论
            2. 而且原码计算如果同号数字相减，且为小数减大数，处理起来也很麻烦
            3. 因此在原码计算中，符号位不能直接参与运算，这加重了计算机的开销
      2. 反码
         1. 正数还是按照原码方式表示，负数在保留符号位不变的情况下对原码取反
         2. 比如x=-1010110,那么$[x]_{原}=10110101$，$[x]_{反}=11001010$
         3. 在这种情况下，0还是有两种表示方式
      3. 补码
         1. 正数：与原码相同
         2. 负数：在反码的基础上再+1
         3. 比如x=-1010110,$[x]_{补}=11001010+1=11001011$
         4. $[[x]_{补}]_{补}=[x]_{原}$
         5. 在补码中，无论是+0，还是-0，他们的表示形式都是00000000
         6. 补码原理：
            1. 使两个二进制数相加为0。比如在4位整型下，5的原码是0101，如果我们能找到一个二进制数与5相加为10000，那么最高位1会因为溢出而变成0000而达成两数之和为0的效果
            2. 要+1，主要是为了弥补反码的不足。反码-5=1010，5=0101，相加为1111，不是0000
            3. 补码这种方式可以直接求得对应的十进制数字，比如$[1010]_2=-2^3+0*2^2+1*2^1+0*2^0=-5$
            4. 为什么上界一般比下界小1：以一个字节(8bit)长度为例。因为在补码体系中，最小的数字为$[1000 0000]_2=-128$，但是最大数字为$[0111 1111]_2=127$
            5. 有符号数与无符号数补码的对应关系：![](./pic/chapter2/18.png)<br>图中T表示有符号类型，U表示无符号类型</p>
   
3. 有符号与无符号数的转换