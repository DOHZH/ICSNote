# Y86-64的指令集体系结构
## 1. 程序员可见状态
1. 程序员不仅指真的程序员，还包括产生机器级代码的编译器
2. 可见状态：只处理器中的某些部分。这些部分每条指令都会去读取或者修改<br>
![](./pic/chapter4/01.PNG)
3. 每个寄存器都存储一个64位的字
4. rsp为栈指针，其他寄存器没有固定含义
5. PC存放当前正在执行的指令的地址
6. Y86-64程序使用虚拟地址引用内存位置
7. 硬件和操作系统软件联合起来将虚拟地址转译为物理地址，用于指明数据实际存在内存中哪个地方
8. Stat记录程序执行的总体状态：是正常运行还是异常

## 2. Y86-64指令
1. X86-64指令集的子集
2. 每条指令均需要1~10个字节
3. 指令编码：
   1. 每条指令第一个字节表明指令类型。高4位为代码部分，低4位为功能部分。比如rrmovq，7表示他的指令类型，0表示他的功能：<br>![](./pic/chapter4/05.PNG)
   2. 寄存器指示符字节
      1. 当指令中有寄存器作为操作数，指令会附加一个字节，这个字节被称作寄存器指示符字节。
      2. 这个字节可以存放一个或两个寄存器
         1. 为了方便操作，我们对寄存器进行了编号：<br>
         ![](./pic/chapter4/03.PNG)
         2. 只需要一个寄存器操作数的指令，比如irmovq、pushq、popq，一般会将另一个寄存器指示符设置为0xF。例子：<br>
         ![](./pic/chapter4/04.PNG)<br>V是立即数，所以第一个寄存器的位置为0xF
4. halt：00，可以使整个系统暂停运行
5. nop：10，表示一个空操作
6. call Dest：80，函数调用，Dest为我们需要调用的函数的名字
7. ret：90，函数返回
8. pushq rA：A0，入栈。rA为寄存器名字
9. popq rA：B0，出栈。rA为寄存器名字
10. mov指令：为了简化x86-64 的指令集，我们将x86-64 中的movq 指令分成了rrmovq、irmovq、rmmovq 和mrmovq 四种。前缀表示源操作数和目的操作数，后缀式数据操作类型。例如irmovq 的源操作数是立即数（Immediate），目的操作数是寄存器（Register）。
11. 其他操作：<br>![](./pic/chapter4/02.PNG)<br>
12. 将汇编代码转译成机械指令：
    1.  汇编代码：rmmovq %rsp, 0x123456789abcd(%rdx)
    2.  首先确定rmmovq，对应编码为0x40
    3.  rsp和rdx分别为0x4和0x2。按照rmmovq的语法规则，组成0x42
    4.  最后，偏移量放在常数字中。常数字占8字节，所以需要对偏移量补0，因此得0x000123456789abcd。因为处理器采用小端法，所以实际写入cd ab 89 67 45 23 01 00
    5.  综上，得机器指令：40 42 cd ab 89 67 45 23 01 00
13. 状态码：
    1.  AOK：程序正常执行
    2.  HLT：处理器执行halt指令
    3.  ADR：处理器试图从非法内存地址读或者向一个非法地址写入。可能是取指令的时候，也可能是读写数据的时候，我们会限制最大的地址，任何访问超出这个限定值的地址都会发生ADR
    4.  INS：非法指令
    5.  编码对应：<br>![](./pic/chapter4/06.PNG)
    6.  一般而言，处理器通常会调用一个异常处理程序，用来处理各种程序异常，而不是像我们的Y86会直接让处理器停止执行指令

## 3. 程序的底层实现
1. Y86-64执行指令的过程组织成如下6个阶段：
   1. 取址：处理器执行所有的指令都需要取址。在Y86-64 指令系统中，指令的长度不是固定的，因此取址阶段需要根据指令代码判断指令是否含有寄存器指示符、是否含有常数来计算当前的指令长度。
   2. 译码：在译码阶段中，处理器从寄存器文件中读取数据。寄存器文件有两个读端口，可以支持同时进行两个读操作。
   3. 执行：指令被正式执行的阶段。在该阶段中，算术逻辑单元（ALU）主要执行三类操作：执行算术逻辑运算、计算内存引用的有效地址、针对push 和pop指令的运算。
   4. 访存：顾名思义，对内存进行读写操作的阶段。
   5. 写回：将执行结果写回到寄存器文件中。
   6. 更新：将PC 更新为下一条指令的地址。
2. 完整的汇编文件：
   1.  源代码：<br>![](./pic/chapter4/07.PNG)
   2.  汇编文件：<br>![](./pic/chapter4/08.PNG)
       1.  汇编器伪指令：以.开头的词，他告诉汇编器调整地址，以便产生代码或者插入数据
       2.  第二行：.pos告诉程序从地址0处产生代码，这个地址是所有Y86-64程序的起点
       3.  第三行：初始化栈指针。第39行.pos 0x200和第40行共同规定了栈从0x200这个地址开始，并且向低地址增长
       4.  8~13行：声明了一个4字的数组（2位16进制为1个字节，所以数组一个单元为16/2=8字节=64bits）。.align指定采用多少字节对齐。这里是8字节对齐。array表明数组的骑士
       5.  16~19：main函数的实现
       6.  sum函数：
           1.  Y86-64将常数加载到寄存器，因为它在算术指令中不可使用立即数。所以会`irmovq $8`, %r8和`irmovq $1, %r9`
3.  subq的指令拆解
    1.  指令：`subq %rdx, %rdx`指令码：6123<br>![](./pic/chapter4/9.PNG)
    2.  取址阶段，根据指令代码来计算指令长度。我们看到指令存完之后，PC指针后移2字节
    3.  译码阶段，根据寄存器指示符来读取寄存器的值
    4.  执行阶段，ALU 根据译码阶段读取到的操作数以及指令来执行具体的运算，并设置条件码寄存器
    5.  访存阶段，由于减法指令不需要读写内存，因此该阶段无操作
    6.  写回阶段，将ALU 的运算结果写回寄存器
    7.  更新阶段，更新程序计数器
4.  irmovq拆解：
    1.  指令：<br>![](./pic/chapter4/10.PNG)
    2.  取址阶段，该指令既含有寄存器指示符字节，也含有常数字段。
    3.  译码阶段，该指令不需要从寄存器中读取数据，译码阶段无操作。
    4.  执行阶段，虽然该指令仅仅传送数据，看似不需要ALU，但由于ALU 的输出端与寄存器的写入端相连，数据的传送还是需要经过ALU，因此该指令将立即数加0.
    5.  访存阶段，该指令不需要读写内存，因此该阶段无操作。
    6.  写回阶段，将ALU 的运算结果写回寄存器。
    7.  更新阶段，更新程序计数器。
5.  rmmovq：
    1.  指令：<br>![](./pic/chapter4/11.PNG)
    2.  取址阶段，该指令既含有寄存器指示符字节，也含有常数字段。
    3.  译码阶段，从寄存器中读取数据。
    4.  执行阶段，ALU 根据偏移量和基址寄存器来计算访存地址。
    5.  访存阶段，将寄存器rsp 的数值写入内存中。
    6.  写回阶段，由于内存地址由执行阶段得出并写入寄存器，因此写回阶段不需要进行操作。
    7.  更新阶段，更新程序计数器。
6.  pushq：
    1.  指令：<br>![](./pic/chapter4/12.PNG)
    2.  取址阶段，该指令含有寄存器指示符，不含常数，因此指令长度为2字节。
    3.  译码阶段，由于pushq 指令要将寄存器rdx 的值保存到栈上，因此该指令不仅需要读取寄存器rdx 的值，还需要读取寄存器rsp的值。
    4.  执行阶段，ALU 计算内存地址。
    5.  访存阶段，将寄存器rdx的值写到栈上。
    6.  写回阶段，由于寄存器rsp指向的内存地址发生了变化，因此更新寄存器rsp的值。
    7.  更新阶段，更新程序计数器。
7.  je：
    1.  指令：<br>![](./pic/chapter4/13.PNG)
    2.  取址阶段，该指令含有常数字段，不含寄存器指示符字节，因此指令长度为9字节。
    3.  译码阶段，不需要读取寄存器，无操作。
    4.  执行阶段，标号为Cond 的硬件单元根据条件码和指令功能来判断是否执行跳转，该模块产生一个信号Cnd，若Cnd = 1，则执行跳转；Cnd = 0 则不执行跳转。
    5.  访存阶段，无操作。
    6.  写回阶段，无操作。
    7.  更新阶段，若Cnd = 1，将PC 的值设为0x040；若Cnd = 0，则将PC的值设为当前值加9