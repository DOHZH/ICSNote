# Y86-64的指令集体系结构
## 1. 程序员可见状态
1. 程序员不仅指真的程序员，还包括产生机器级代码的编译器
2. 可见状态：只处理器中的某些部分。这些部分每条指令都会去读取或者修改<br>
![](./pic/chapter4/01.PNG)
3. 每个寄存器都存储一个64位的字
4. rsp为栈指针，其他寄存器没有固定含义
5. PC存放当前正在执行的指令的地址
6. Y86-64程序使用虚拟地址引用内存位置
7. 硬件和操作系统软件联合起来将虚拟地址转译为物理地址，用于指明数据实际存在内存中哪个地方
8. Stat记录程序执行的总体状态：是正常运行还是异常

## 2. Y86-64指令
1. X86-64指令集的子集
2. 每条指令均需要1~10个字节
3. 指令编码：
   1. 每条指令第一个字节表明指令类型。高4位为代码部分，低4位为功能部分。比如rrmovq，7表示他的指令类型，0表示他的功能：<br>![](./pic/chapter4/05.PNG)
   2. 寄存器指示符字节
      1. 当指令中有寄存器作为操作数，指令会附加一个字节，这个字节被称作寄存器指示符字节。
      2. 这个字节可以存放一个或两个寄存器
         1. 为了方便操作，我们对寄存器进行了编号：<br>
         ![](./pic/chapter4/03.PNG)
         2. 只需要一个寄存器操作数的指令，比如irmovq、pushq、popq，一般会将另一个寄存器指示符设置为0xF。例子：<br>
         ![](./pic/chapter4/04.PNG)<br>V是立即数，所以第一个寄存器的位置为0xF
4. halt：00，可以使整个系统暂停运行
5. nop：10，表示一个空操作
6. call Dest：80，函数调用，Dest为我们需要调用的函数的名字
7. ret：90，函数返回
8. pushq rA：A0，入栈。rA为寄存器名字
9. popq rA：B0，出栈。rA为寄存器名字
10. mov指令：为了简化x86-64 的指令集，我们将x86-64 中的movq 指令分成了rrmovq、irmovq、rmmovq 和mrmovq 四种。前缀表示源操作数和目的操作数，后缀式数据操作类型。例如irmovq 的源操作数是立即数（Immediate），目的操作数是寄存器（Register）。
11. 其他操作：<br>![](./pic/chapter4/02.PNG)<br>
12. 将汇编代码转译成机械指令：
    1.  汇编代码：rmmovq %rsp, 0x123456789abcd(%rdx)
    2.  首先确定rmmovq，对应编码为0x40
    3.  rsp和rdx分别为0x4和0x2。按照rmmovq的语法规则，组成0x42
    4.  最后，偏移量放在常数字中。常数字占8字节，所以需要对偏移量补0，因此得0x000123456789abcd。因为处理器采用小端法，所以实际写入cd ab 89 67 45 23 01 00
    5.  综上，得机器指令：40 42 cd ab 89 67 45 23 01 00
13. 状态码：
    1.  AOK：程序正常执行
    2.  HLT：处理器执行halt指令
    3.  ADR：处理器试图从非法内存地址读或者向一个非法地址写入。可能是取指令的时候，也可能是读写数据的时候，我们会限制最大的地址，任何访问超出这个限定值的地址都会发生ADR
    4.  INS：非法指令
    5.  编码对应：<br>![](./pic/chapter4/06.PNG)
    6.  一般而言，处理器通常会调用一个异常处理程序，用来处理各种程序异常，而不是像我们的Y86会直接让处理器停止执行指令
14. 